rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a security model centered on user privacy
     * and controlled collaboration. User data is strictly owned by the user, while
     * shared data (like matches and messages) is accessible only to the involved
     * participants. Publicly available data, such as prompts, is read-only.
     *
     * Data Structure:
     * - /users/{userId}/...: All user-specific private data (profile, swipes, likedBy)
     * - /matches/{matchId}/...: Collaborative data representing a match between two users.
     * - /prompts/{promptId}: A top-level collection for public, read-only data.
     * - /compatibilityRadarCharts/{chartId}: Top-level collection for user-specific data.
     *
     * Key Security Decisions:
     * - Default Deny: All paths are closed by default. Access must be explicitly granted.
     * - User Discovery: Authenticated users can list and get other user profiles for discovery.
     * - Strict Ownership: A user can only create/modify data within their own data tree.
     * - Shared Access via Denormalization: The `/matches/{matchId}` documents contain
     *   an array of user IDs (`users`). This is used to grant access to the match
     *   document and its `messages` subcollection, avoiding complex queries.
     * - Public Data is Read-Only: The `/prompts` collection is readable by any signed-in
     *   user but cannot be modified by clients, ensuring data integrity.
     */

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document already exists in Firestore.
     * Crucial for update and delete operations to prevent acting on non-existent data.
     */
    function isExistingDocument() {
      return resource != null;
    }

    /**
     * Checks if the requesting user is a participant in a given match document.
     * This function now checks an array `users` for the requesting user's UID.
     */
    function isMatchParticipant(matchDoc) {
      return isSignedIn() && request.auth.uid in matchDoc.data.users;
    }

    /**
     * Checks if the requesting user is a participant in the PARENT match document.
     * Used to secure subcollections like `/messages`. Requires a `get()` call.
     */
    function isParentMatchParticipant(matchId) {
      let matchDoc = get(/databases/$(database)/documents/matches/$(matchId));
      return isMatchParticipant(matchDoc);
    }

    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (read) Any signed-in user for profile discovery.
     * @allow (create, update, delete) Only the user themselves.
     */
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDocument() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDocument();

      /**
       * @description Manages a user's swipe history (likes, nopes).
       * @path /users/{userId}/swipes/{targetUserId}
       * @allow (get, list, create, update) Only the owner of the subcollection.
       * @principle A user can only manage their own outgoing swipes.
       */
      match /swipes/{targetUserId} {
        allow read, write: if isOwner(userId);
      }

      /**
       * @description Records who has liked a user.
       * @path /users/{userId}/likedBy/{likerId}
       * @allow (create, read) Any signed-in user can record a 'like' on another user's profile.
       * @deny (update, delete, list) To prevent manipulation or snooping.
       * @principle Enables the "likes you" feature without exposing the full list.
       */
      match /likedBy/{likerId} {
         allow get, create: if isSignedIn() && request.auth.uid == likerId;
         allow list, update, delete: if false;
      }
    }


    /**
     * @description Stores match data between two users. Only the two matched users can access it.
     * @path /matches/{matchId}
     * @allow (get) Any user who is part of the match's `users` array.
     * @allow (create) The user creating the match must be one of the participants.
     * @deny (list) Listing all matches in the system is forbidden for security.
     */
    match /matches/{matchId} {
      allow get: if isMatchParticipant(resource);
      allow list: if false; // Security: Don't allow anyone to list all matches.
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.users;
      allow update: if isMatchParticipant(resource) && isExistingDocument();
      allow delete: if isMatchParticipant(resource) && isExistingDocument();
    }

    /**
     * @description Stores chat messages within a match. Only the two matched users can read or send messages.
     * @path /matches/{matchId}/messages/{messageId}
     * @allow (list, create) A participant in the parent match can list or create a message.
     * @principle Inherits access control from the parent document using a `get()` call.
     */
    match /matches/{matchId}/messages/{messageId} {
      allow get, list: if isParentMatchParticipant(matchId);
      allow create: if isParentMatchParticipant(matchId) && request.resource.data.senderId == request.auth.uid;
      allow update: if isParentMatchParticipant(matchId) && isExistingDocument() && request.resource.data.senderId == resource.data.senderId;
      allow delete: if isParentMatchParticipant(matchId) && isExistingDocument() && resource.data.senderId == request.auth.uid;
    }

    /**
     * @description Stores predefined prompt questions. This data is public and read-only for all signed-in users.
     * @path /prompts/{promptId}
     */
    match /prompts/{promptId} {
      allow get, list: if isSignedIn();
      allow write: if false;
    }

    /**
     * @description Stores compatibility radar chart data. Access is currently denied pending schema update.
     * @path /compatibilityRadarCharts/{compatibilityRadarChartId}
     */
    match /compatibilityRadarCharts/{compatibilityRadarChartId} {
      // CRITICAL: Cannot implement secure rules for this collection. The 'CompatibilityRadarChart'
      // entity is missing an 'ownerId' or 'userId' field to link it to a user.
      // To enable access, update the schema to include an ownership field.
      allow read, write: if false;
    }
  }
}
